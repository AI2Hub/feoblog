<div class="dualPaneEditor">
    {#if mode === "profile"}
        <EditProfile 
            {appState} 
            {initialItem}
            bind:validationErrors
            bind:item
        />
    {:else} <!-- mode === "post" -->
        <EditPost
            bind:validationErrors
            bind:item
        />
    {/if}
    
    <!-- Preview: -->
    <ItemView
        {appState}
        userID={userID.toString()}
        signature="unknown"
        {item}
        linkMode="newWindow"
    />

    <!-- Sign & Send -->
    <div class="item sendBox inputWhiteBox">
        {#if errors.length > 0}
            <div class="error">
                {#each errors as error}
                    {error}<br>
                {/each}
            </div>
        
        {:else if !validSignature}
            <InputBox 
                inputType="password"
                label="Private Key"
                bind:value={privateKey}
                bind:errorMessage={privateKeyError}
            />
            <Button on:click={sign} disabled={!validPrivateKey}>Sign</Button>
        {:else}
            <InputBox
                label="Signature"
                value={signature}
                disabled={true}
             />
            <div class="buttons">
                <Button on:click={submit}>Submit</Button>
            </div>
            {#if status}
                <div>{status}</div>
            {/if}
        {/if}
    </div>

</div>


<script lang="ts">
import type { Writable } from "svelte/store"
import bs58 from "bs58"
import { Item } from "../protos/feoblog"
import * as nacl from "tweetnacl-ts"
import bs58check from 'bs58check'
import { DateTime } from "luxon"

import { MAX_ITEM_SIZE } from '../ts/common'
import type { UserID as ClientUserID } from "../ts/client"
import type { AppState } from '../ts/app';
import ItemView from './ItemView.svelte'
import Button from './Button.svelte'
import InputBox from './InputBox.svelte';
import EditProfile from './EditProfile.svelte';
import EditPost from './EditPost.svelte';

export let appState: Writable<AppState>

// What kind of thing are we editing?
// I imagine I'll want to make a "reply" type here too.
// There will probably be a separate, inline editor for "comment" types since they'll be simpler.
export let mode: "post"|"profile" = "post"

// Can provide an initial item for editing.
export let initialItem: Item|undefined = undefined

// May be provided externally if we were provided an item
// TODO: TBH, the fact that this works w/ an initialItem: Item above is just an
// artifact of our serializer having a deterministic output. That may not be the case
// and we may want to pass itemBytes here if we want to verify the signature of profiles
// we load.  Though, maybe that's just not worth it.
export let signature = ""


let userID: ClientUserID
$: userID = function() {
    let userID = $appState.loggedInUser
    if (userID) return userID
    throw `Must be logged in.`
}()

// Validation Errors from EditProfile/EditPost:
let validationErrors: string[] = []
// The Item protobuf generated by EditProfile/EditPost.
let item: Item = new Item()


// errors including validationErrors and additional checks:
let errors: string[] = []
$: errors = function() {
    let errors = [...validationErrors]
    if (protoSize > MAX_ITEM_SIZE) {
        errors.push(`Item is ${protoSize} bytes but max size is ${MAX_ITEM_SIZE}`)
    }
    if (!item.timestamp_ms_utc) {
        errors.push(`A timestamp is required`)
    }

    let now = DateTime.local().valueOf()
    if (item.timestamp_ms_utc > now.valueOf()) {
        // Technically, servers allow some leniency here, but, eh:
        errors.push("Date must not be in the future.")
    }

    return errors
}()

// The result of the last submit()
let status = ""


let privateKey = ""

// TODO: Move parsing a private key to a separate function and component.
// Error to display about the private key:
$: privateKeyError = function() {
    if (privateKey.length == 0) {
        return "";
    }
    
    let buf: Uint8Array;
    try {
        buf = bs58.decode(privateKey)
    } catch (error) {
        return "Not valid base58"
    }

    // Secret is 32 bytes, + 4 for checked base58.
    if (buf.length < 36) {
        return "Password is too short."
    }
    if (buf.length > 36) {
        return "Password is too long."
    }

    try {
        buf = bs58check.decode(privateKey)
    } catch (e) {
        return "Invalid Password"
    }

    
    let keypair = nacl.sign_keyPair_fromSeed(buf);
    
    let pubKey = bs58.encode(keypair.publicKey)
    if (pubKey != userID.toString()) {
        return "Private key does not match user ID."
    }

    return ""    
}()

// We have a key which could be used to sign.
$: validPrivateKey = privateKey.length > 0 && privateKeyError == ""
$: itemProtoBytes = item.serialize()
$: protoSize = itemProtoBytes?.length || 0

$: validSignature = function(): boolean {
    if (!userID || !signature || !itemProtoBytes) {
        return false
    }

    let isValid = false
    try {
        let pubKey = userID.bytes
        let decodedSig = bs58.decode(signature)
        isValid = nacl.sign_detached_verify(itemProtoBytes, decodedSig, pubKey)
    } catch (error) {
        console.error("Error validating signature:", error)
    }

    // Re-validating a signature on every keypress is *expensive*.
    // If we've started editing and this signature is no longer valid, delete it so
    // that we can short-circuit (above)
    if (!isValid) {
        unSign()
    }

    return isValid
}()


// Create a signature, delete the password.
async function sign() {

    if (privateKeyError) {
        console.error("Shouldn't be able to call sign w/ invalid private key.")
        return
    }

    if (!itemProtoBytes) throw `No bytes to sign.`
   
    let buf = bs58check.decode(privateKey)
    let keypair = nacl.sign_keyPair_fromSeed(buf);
    let binSignature = nacl.sign_detached(itemProtoBytes, keypair.secretKey)
    signature = bs58.encode(binSignature)

    // Delete the privateKey, we don't want to save it any longer than
    // necessary:
    privateKey = ""
}

function unSign() {
    signature = ""
}

// TODO: Move to Client.
async function submit() {
    if ( (errors.length > 0) || !validSignature) {
        console.error("Submit clicked when not valid");
        return;
    }

    let url = `/u/${userID}/i/${signature}/proto3`
    let bytes = itemProtoBytes;
    status = "Making request"
    
    let response: Response
    try {
        response = await fetch(url, {
            method: "PUT",
            body: bytes,
        })
    } catch (e) {
        console.error("PUT exception:", e)
        status = `PUT exception: ${e}`
        return 
    }


    let code = response.status
    let message = await response.text()
    status = `${code}: ${message}`
}

</script>

<style>
.buttons {
    margin-top: 1em;
}
</style>